<!DOCTYPE html>
<meta charset="UTF-8">

<style>
  /* マウスカーソルの非表示 */

  html,
  body {
    cursor: none;
  }

  #hako {
    width: 1200px;
    height: 800px;
    margin-left: auto;
    margin-right: auto;
  }
</style>

<title>Mouse Stalker</title>

<body>

  <div id="hako">
    <canvas id="can"></canvas>
  </div>

  <script>

    //ゲームスピード
    const GAME_SPEED = 1000 / 60;

    //画面サイズ
    const SCREEN_W = 1200;
    const SCREEN_H = 800;

    //キャンバスサイズ
    const CANVAS_W = SCREEN_W;
    const CANVAS_H = SCREEN_H;

    //フィールドサイズ
    const FIELD_W = SCREEN_W * 2;
    const FIELD_H = SCREEN_H * 2;

    //キャンバス
    let can = document.getElementById("can");
    let con = can.getContext("2d");
    can.width = CANVAS_W;
    can.height = CANVAS_H;

    //フィールド仮想画面
    let vcan = document.createElement("canvas");
    let vcon = vcan.getContext("2d");
    vcan.width = FIELD_W;
    vcan.height = FIELD_H;

    //カメラの座標
    let camera_x = 0;
    let camera_y = 0;

    //自機の座標
    let jiki_x = 0;
    let jiki_y = 0;
    var mouse = new Point();

    //自機が向いている方向
    let direc = 0;

    //自機のショット
    const CHARA_SHOT_MAX_COUNT = 100;
    let fire = false;

    //ショットが段々大きくなる
    let blastInit = 0.5;//大きくなる速度
    let blastShot = blastInit;

    function CharacterShot() {
      this.position = new Point();
      this.size = 0;
      this.speed = 0;
      this.alive = false;
    }

    CharacterShot.prototype.set = function (p, size, speed) {
      //座標をセット
      this.position.x = p.x;
      this.position.y = p.y;

      //サイズ、スピードをセット
      this.size = size;
      this.speed = speed;

      //生存フラグを立てる
      this.alive = true;
    }

    // var length = 1000;
    // var initial = 4;
    // var ratio = -2;
    // var arr = Array.apply(null, new Array(length)).map(function (v, i) { return initial * Math.pow(ratio, i); });
    let burst = 0;
    let burstCount = 0;

    CharacterShot.prototype.move = function () {
      this.size += blastShot;
      this.speed += blastShot;

      //座標を真上にspeed分だけ移動させる
      this.position.y -= this.speed;
      this.position.x += burst;

      //一定以上の座標に到達していたら生存フラグを降ろす
      if (this.position.y < -this.size) {
        this.alive = false;
      }
    }

    //ショットの初期化
    var charaShot = new Array(CHARA_SHOT_MAX_COUNT);
    for (i = 0; i < CHARA_SHOT_MAX_COUNT; i++) {
      charaShot[i] = new CharacterShot();
    }

    //画像ファイルを読み込み
    // let spriteImage = new Image();
    // spriteImage.src = "../images/testC.png";

    //スプライトクラス
    // class Sprite{
    //   constructor(x,y,w,h){
    //     this.x = x;
    //     this.y = y;
    //     this.w = w;
    //     this.h = h;
    //   }
    // }

    //スプライト
    // let sprite = [
    //   new Sprite(4,13,28,45),
    //   new Sprite(100,13,28,45),
    //   new Sprite(4,62,28,45),
    //   new Sprite(100,62,28,45),
    //   new Sprite(4,110,28,45),
    //   new Sprite(100,110,28,45),
    //   new Sprite(4,158,28,45),
    //   new Sprite(99,158,28,45)
    // ];

    //スプライトを描画する
    // function drawSprite(snum,x,y){
    //   let sx = sprite[snum].x;
    //   let sy = sprite[snum].y;
    //   let sw = sprite[snum].w;
    //   let sh = sprite[snum].h;

    //   vcon.drawImage(spriteImage,sx,sy,sw,sh,x,y,sw,sh);
    // }

    // draw(){

    // }

    // update(){

    // }

    function Point() {
      this.x = 0;
      this.y = 0;
    }

    //自機
    function Jiki() {
      this.position = new Point();
      this.size = 0;
    }
    Jiki.prototype.init = function (size) {
      this.size = size;
    }

    //自機初期化
    var jiki = new Jiki();
    jiki.init(10);

    //ゲーム初期化
    function gameInit() {
      setInterval(gameLoop, GAME_SPEED);
    }

    //ゲームループ
    function gameLoop() {
      //移動の処理
      burstCount++;
      if(burstCount < 2){
        burst = 5;
      }else if(burstCount < 4){
        burst = -5;
      }else if(burstCount < 10){
        burst = 10;
      }else if(burstCount < 16){
        burst= -10;
      }else{
        burstCount = 0;
      }


      //描画の処理
      vcon.fillStyle = "black";
      vcon.fillRect(0, 0, SCREEN_W, SCREEN_H);

      if (direc == 0) {
        vcon.fillStyle = "red";
      } else if (direc == 1) {
        vcon.fillStyle = "blue";
      } else if (direc == 2) {
        vcon.fillStyle = "yellow";
      } else if (direc == 3) {
        vcon.fillStyle = "cyan";
      } else if (direc == 4) {
        vcon.fillStyle = "orange";
      } else if (direc == 5) {
        vcon.fillStyle = "pink";
      } else if (direc == 6) {
        vcon.fillStyle = "green";
      } else {
        vcon.fillStyle = "white";
      }
      vcon.fillRect(100, 100, 100, 100);

      //パスの設定を開始
      vcon.beginPath();

      //自機の位置を設定
      jiki.position.x = mouse.x;
      jiki.position.y = mouse.y;

      //自機を描くパスを設定
      vcon.arc(jiki.position.x, jiki.position.y, 10, 0, Math.PI * 2, false);

      //自機の色を設定する
      vcon.fillStyle = "blue";

      //自機を描く
      vcon.fill();

      //自機ショットのパスを設定
      vcon.beginPath();
      //自機ショットのチェック（描画用）
      for (i = 0; i < CHARA_SHOT_MAX_COUNT; i++) {
        //ショットはもう発射されてる？
        if (charaShot[i].alive) {
          //ショットを動かす
          charaShot[i].move();

          //ショットを描くパスを設定
          vcon.arc(
            charaShot[i].position.x,
            charaShot[i].position.y,
            charaShot[i].size,
            0, Math.PI * 2, false
          );
          //パスをいったん閉じる
          vcon.closePath();
        }
      }
      //自機ショットの色を設定
      vcon.fillStyle = "red";
      //自機ショットを描く
      vcon.fill();

      // drawSprite(0,100,100);

      //仮想画面から実際のキャンバスにコピー
      con.drawImage(vcan, 0, 0, SCREEN_W, SCREEN_H, 0, 0, CANVAS_W, CANVAS_H);

      //ショット
      if (fire) {
        //自機ショットのチェック
        for (i = 0; i < CHARA_SHOT_MAX_COUNT; i++) {
          //ショットが既に発射されているか？
          if (!charaShot[i].alive) {
            //ショットを自機の位置にセット、サイズ、速度
            charaShot[i].set(jiki.position, 3, 20);
            //ループを抜ける
            break;
          }
        }
      }
      
    }

    window.onload = function () {
      gameInit();
    }

    // let direc = 0;

    // function barrettDirection(imageList){
    //   let imagesBD = imageList.map(src => Object.assign(new Image, { src }));

    //   if(imagesBD == images[0].src){
    //     direc = 1;
    //   }
    // }

    can.addEventListener("mousemove", mouseMove, true);
    function mouseMove(event) {
      //マウスカーソル座標の更新
      mouse.x = event.clientX - can.offsetLeft;
      mouse.y = event.clientY - can.offsetTop;
    }

    //スペースキーで方向をロック
    let rockOn = false;
    document.addEventListener("keydown", keyDown, true);
    function keyDown(e) {
      if (e.keyCode == 32) {
        rockOn = true;
      }
    }
    document.addEventListener("keyup", keyUp, true);
    function keyUp(e) {
      if (e.keyCode == 32) {
        rockOn = false;
      }
    }

    //マウスボタンを押下した時
    document.addEventListener("mousedown", mouseDown, true);
    function mouseDown(event) {
      event.preventDefault();
      if (event.which == 1) {
        console.log("左クリック");
        fire = true;
      }
      if (event.which == 2) {
        console.log("中クリック");
      }
      if (event.which == 3) {
        console.log("右クリック");
      }
    }

    //マウスボタンから指を離した時
    document.addEventListener("mouseup", mouseUp, true);
    function mouseUp(event) {
      if (event.which == 1) {
        console.log("左クリック離された");
        blastShot = blastInit;
        fire = false;
      }
      if (event.which == 2) {
        console.log("中クリック離された");
      }
      if (event.which == 3) {
        console.log("右クリック離された");
      }
    }

    //右クリックのメニュー無効
    // document.addEventListener('contextmenu', function (e) {
    //   e.preventDefault();
    // });
    // document.oncontextmenu = function () {
    //   return false;
    // };

    //マウスホイール
    document.onmousewheel = function (event) {
      console.log(event.wheelDelta);
    }

    //ドラッグのデフォルト動作無効
    function DragStartFunc(e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        return false;
      }
    }
    document.addEventListener("dragstart", DragStartFunc);


    class P2 {
      constructor(x = 0, y = 0) { this.x = x; this.y = y }
      get clone() { return new P2(this.x, this.y) }//複写
      add({ x = 0, y = 0 }, { x: X, y: Y } = this) { this.x = X + x; this.y = Y + y; return this }//加算
      sub({ x = 0, y = 0 }, { x: X, y: Y } = this) { this.x = X - x; this.y = Y - y; return this }//減算
      mul({ x = 0, y = 0 }, { x: X, y: Y } = this) { this.x = X * x; this.y = Y * y; return this }//乗算
      div({ x = 0, y = 0 }, { x: X, y: Y } = this) { this.x = X / x; this.y = Y / y; return this }//除算
      sMul(n = 0, { x: X, y: Y } = this) { this.x = X * n; this.y = Y * n; return this }//スカラー倍
    }
    //__

    //追いかける素となるもの（マウスの座標）
    class MousePointer extends P2 {
      constructor(x, y) {
        super(x, y);
      }

      handleEvent(event) {
        this.x = event.clientX + window.pageXOffset - 12;
        this.y = event.clientY + window.pageYOffset - 12;
      }

      static create(view = can) {
        let obj = new this();
        view.addEventListener('mousemove', obj, false);
        return obj;
      }
    }

    //__
    //追いかけるもの
    class Stalker extends P2 {
      constructor(target, images, pointer, option = {}) {
        super(pointer.x, pointer.y);
        this.target = target;
        this.images = images;
        this.pointer = pointer;
        this.option = Object.assign({}, this.constructor.getDefaultOption(), option);
        this.disabled = false;

        this.chase();
      }


      chase() {
        const { PI, floor: int } = Math;
        if (this.disabled) return;
        let
          dp = this.pointer.clone.sub(this),
          n = 360 / this.images.length,
          ang = Math.atan2(dp.x, -dp.y) * 180 / PI;

        this.add(dp.sMul(this.option.accelerator));
        this.locate();
        if (!rockOn) this.target.src = this.images[int((360 + ang) % 360 / n)].src;
        if (this.target.src == this.images[0].src) direc = 0;
        if (this.target.src == this.images[1].src) direc = 1;
        if (this.target.src == this.images[2].src) direc = 2;
        if (this.target.src == this.images[3].src) direc = 3;
        if (this.target.src == this.images[4].src) direc = 4;
        if (this.target.src == this.images[5].src) direc = 5;
        if (this.target.src == this.images[6].src) direc = 6;
        if (this.target.src == this.images[7].src) direc = 7;
        requestAnimationFrame(this.chase.bind(this));
      }


      locate() {
        const int = Math.floor;
        let p = this.option.offset.clone.add(this);
        Object.assign(this.target.style, { left: int(p.x) + 'px', top: int(p.y) + 'px' });
        return this;
      }


      static getDefaultOption() {
        return {
          offset: new P2(0, 0),
          accelerator: .9
        };
      }


      static create(imageList, pointer, option = {}) {
        let
          div = document.createElement('div'),
          target = new Image,
          style = { position: 'absolute', left: '0px', top: '0px' },
          images = imageList.map(src => Object.assign(new Image, { src }));

        target.src = images[0].src;
        Object.assign(div.style, style);
        Object.assign(target.style, style);
        document.body.appendChild(div).appendChild(target);

        return new Stalker(target, images, pointer, option);
      }
    }

    //__ 

    const src = [
      "../images/testC6.png",
      "../images/testC7.png",
      "../images/testC4.png",
      "../images/testC3.png",
      "../images/testC0.png",
      "../images/testC1.png",
      "../images/testC2.png",
      "../images/testC5.png",
      // 'data:image/gif;base64,R0lGODlhIAAgAJEAAPwAAYcAAf///wAAACH5BAEAAAIALAAAAAAgACAAAAJklI+py33gYgsAymsCrVjqzXXMB4YiQpbmmaor1rpvFMvzWFf6bjm1xgv6frYdjhhMKoifpJKWerKiwpOgJRVhq1NStrPlWa9UsTVsPJfT3SZXu9aN0XK19w2O3zz6HvxuNiZYAAA7',
      // 'data:image/gif;base64,R0lGODlhIAAgAJEAAPwAAYcAAf///wAAACH5BAEAAAIALAAAAAAgACAAAAJklI+py+0Po5xUhIuzziDuz3UeuAHmRIYnmppuRbovBcqzVNvrWOr7k/OJgB/hrRE0EnvGnyLZRBabMgbUJsA+p8JDdauJIo6IsFLhLF/Ei+EiwK4YzvKxrt7+4tHpvdcPGChRAAA7',
      // 'data:image/gif;base64,R0lGODlhIAAgAJEAAPwAAYcAAf///wAAACH5BAEAAAIALAAAAAAgACAAAAJXlI+py+0Po2Rh2lBtxFk73nkLGIoIWZoCmh7sC1PwTI70jSn4nuy868MdAMSi8YhMEg3KpnPJfEqNiKk1YZUqss4FV6kaIsNiKjlaPJcB6nJb/B7G56oCADs=',
      // 'data:image/gif;base64,R0lGODlhIAAgAJEAAPwAAYcAAf///wAAACH5BAEAAAIALAAAAAAgACAAAAJjlI+py+0Po5zUhFDhvbnt3SnfFx4AMILheaacx7Csiy1vIsu0eJu57kKQFD9gyjIkFlu0UWPJbPaUS+mUWrRCoKhmhOv9QncS8HFiTpbH6i23e32+o+s5U2yfufOykv8P6FAAADs=',
      // 'data:image/gif;base64,R0lGODlhIAAgAJEAAPwAAYcAAf///wAAACH5BAEAAAIALAAAAAAgACAAAAJnlI+pywkPQZi02QhptQw/PXGdBwbi4kngqaQl65ArfLgzLdgabugb7gvxgqahbGfEvJKRJfD4a6SIpSJiqqwiW9iPVjjCfq1SsZZldp6mVWbm9mxueTk5mN57k/F5FR8l8dchSChQAAA7',
      // 'data:image/gif;base64,R0lGODlhIAAgAJEAAPwAAYcAAf///wAAACH5BAEAAAIALAAAAAAgACAAAAJmlI+py+0PE4j0gFvj3dnt3y3fGCLjGHjN+QXuOins5tYMZ85AzYu4oNvxbDJQcEgsBmnI1G15aTqfS+kDar0emxpdFuLlUmbfLkpcOUmn49aaDWa+4Z7oPKm9DzV6ZOkPGCg4yFAAADs=',
      // 'data:image/gif;base64,R0lGODlhIAAgAJEAAPwAAYcAAf///wAAACH5BAEAAAIALAAAAAAgACAAAAJXlI+py+0PAZwJSErtxU9vzngfWInkIlpnmbbuaLxyqsy2xt4zoutH7xMAg4KA8YhMKpcBBPMJbTqj1KOiWl1go4zts7FcXZPisbWcQKLN63H7+o7L54cCADs=',
      // 'data:image/gif;base64,R0lGODlhIAAgAJEAAPwAAYcAAf///wAAACH5BAEAAAIALAAAAAAgACAAAAJflI+py+0PYwO02nthwDzr3XFSQIZeRJYmIBmp2rXuC8YtDYsjXusfb0LxcpjfMOgYvpAM5TLUcD5tCtoMx0S8tEBoIlXtFsNNcaWZNMu+3XUY517A43IwvXzP6/d8fQEAOw=='
    ];

    let
      pointer0 = MousePointer.create(),
      pointer1 = Stalker.create(src, pointer0, { offset: new P2(), accelerator: .4 });

  </script>

</body>